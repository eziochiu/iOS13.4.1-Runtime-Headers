/* Generated by EzioChiu
   Image: /System/Library/Frameworks/CoreTelephony.framework/CoreTelephony
 */

@interface CoreTelephonyClientMux : NSObject <MuxNotificationSinkDelegate> {
    NSXPCConnection * _connection;
    NSSet * _currentSelectorSet;
    struct map<__unsafe_unretained id, (anonymous namespace)::DelegateContext, std::__1::less<__unsafe_unretained id>, std::__1::allocator<std::__1::pair<const __unsafe_unretained id, (anonymous namespace)::DelegateContext> > >="__tree_"{__tree<std::__1::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::__1::__map_value_compare<__unsafe_unretained id, std::__1::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext>, std::__1::less<__unsafe_unretained id>, true>, std::__1::allocator<std::__1::__value_type<__unsafe_unretained id, (anonymous namespace)::DelegateContext> > >="__begin_node_"^{__tree_end_node<std::__1::__tree_node_base<void *> *> {}  _delegates;
    NSXPCListenerEndpoint * _endpoint;
    MuxNotificationSink * _notificationSink;
    NSError * _reconnectError;
    struct queue { 
        struct object { 
            struct dispatch_object_s {} *fObj; 
        } fObj; 
    }  _xpcQueue;
}

@property (nonatomic, retain) NSXPCConnection *connection;
@property (nonatomic, retain) NSXPCListenerEndpoint *endpoint;
@property (nonatomic, retain) MuxNotificationSink *notificationSink;
@property (nonatomic, retain) NSError *reconnectError;
@property (nonatomic) struct queue { struct object { struct dispatch_object_s {} *x_1_1_1; } x1; } xpcQueue;

- (id).cxx_construct;
- (void).cxx_destruct;
- (void)_computeNotificationSetForced_sync;
- (void)_computeNotificationSetForced_sync:(id /* block */)arg1;
- (void)_computeNotificationSet_sync:(id /* block */)arg1;
- (void)_computeNotificationSet_sync:(bool)arg1 completion:(id /* block */)arg2;
- (void)_connect_sync;
- (id)_connection;
- (void)_ensureConnectionSetup_sync;
- (void)_ensureConnectionSetup_sync:(bool)arg1;
- (void)_initializeConnection_sync;
- (void)_registerForNotifications_sync:(id)arg1 shouldForce:(bool)arg2 completion:(id /* block */)arg3;
- (void)_setReconnectError_sync:(id)arg1;
- (void)addDelegate:(id)arg1 queue:(struct queue { struct object { struct dispatch_object_s {} *x_1_1_1; } x1; })arg2;
- (id)connection;
- (void)dealloc;
- (id)endpoint;
- (id)init;
- (id)initWithEndpoint:(id)arg1 sink:(id)arg2;
- (id)initWithSink:(id)arg1;
- (id)notificationSink;
- (id)proxyWithErrorHandler_sync:(id /* block */)arg1;
- (id)proxyWithQueue:(struct queue { struct object { struct dispatch_object_s {} *x_1_1_1; } x1; })arg1 errorHandler:(id /* block */)arg2;
- (id)reconnectError;
- (void)removeDelegate:(id)arg1;
- (void)setConnection:(id)arg1;
- (void)setEndpoint:(id)arg1;
- (void)setNotificationSink:(id)arg1;
- (void)setReconnectError:(id)arg1;
- (void)setXpcQueue:(struct queue { struct object { struct dispatch_object_s {} *x_1_1_1; } x1; })arg1;
- (void)sink:(id)arg1 handleNotification:(id)arg2;
- (id)synchronousProxyWithErrorHandler:(id /* block */)arg1;
- (struct queue { struct object { struct dispatch_object_s {} *x_1_1_1; } x1; })xpcQueue;

@end
