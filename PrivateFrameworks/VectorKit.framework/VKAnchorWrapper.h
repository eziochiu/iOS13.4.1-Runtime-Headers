/* Generated by EzioChiu
   Image: /System/Library/PrivateFrameworks/VectorKit.framework/VectorKit
 */

@interface VKAnchorWrapper : NSObject <VKAnchorDelegate> {
    struct shared_ptr<md::Anchor> { 
        struct Anchor {} *__ptr_; 
        struct __shared_weak_count {} *__cntrl_; 
    }  _anchor;
    struct AnchorManager { int (**x1)(); bool x2; struct GlobeView {} *x3; struct MercatorTerrainHeightCache {} *x4; struct unordered_set<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> > { struct __hash_table<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> {} **x_1_4_1; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > { unsigned long long x_1_6_1; } x_2_5_1; } x_1_4_2; } x_1_3_1; } x_1_2_1; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>, std::__1::allocator<std::__1::__hash_node<md::Anchor *, void *> > > { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> {} *x_1_4_1; } x_2_3_1; } x_1_2_2; } x_5_1_1; } x5; } * _anchorManager;
    const struct CameraContext { int (**x1)(); struct SingleCameraContext { int (**x_2_1_1)(); struct CameraView { struct Camera { struct CameraFrame<geo::Radians, double> { struct Coordinate3D<Radians, double> { struct Unit<RadianUnitDescription, double> { double x_1_6_1; } x_1_5_1; struct Unit<RadianUnitDescription, double> { double x_2_6_1; } x_1_5_2; struct Unit<MeterUnitDescription, double> { double x_3_6_1; } x_1_5_3; } x_1_4_1; struct Unit<MeterUnitDescription, double> { double x_2_5_1; } x_1_4_2; struct Unit<RadianUnitDescription, double> { double x_3_5_1; } x_1_4_3; struct Unit<RadianUnitDescription, double> { double x_4_5_1; } x_1_4_4; struct Unit<RadianUnitDescription, double> { double x_5_5_1; } x_1_4_5; } x_1_3_1; struct ViewSize { unsigned short x_2_4_1; unsigned short x_2_4_2; } x_1_3_2; struct Unit<RadianUnitDescription, double> { double x_3_4_1; } x_1_3_3; struct Unit<MeterUnitDescription, double> { double x_4_4_1; } x_1_3_4; struct Unit<MeterUnitDescription, double> { double x_5_4_1; } x_1_3_5; double x_1_3_6; struct Matrix<float, 2, 1> { float x_7_4_1[2]; } x_1_3_7; } x_2_2_1; struct PerspectiveView<double> { struct RigidTransform<double, double> { struct Matrix<double, 3, 1> { double x_1_5_1[3]; } x_1_4_1; struct Quaternion<double> { struct Matrix<double, 3, 1> { double x_1_6_1[3]; } x_2_5_1; double x_2_5_2; } x_1_4_2; } x_2_3_1; struct Matrix<double, 4, 4> { double x_2_4_1[16]; } x_2_3_2; struct Matrix<double, 4, 4> { double x_3_4_1[16]; } x_2_3_3; struct Matrix<double, 4, 4> { double x_4_4_1[16]; } x_2_3_4; double x_2_3_5; double x_2_3_6; struct ViewSize { unsigned short x_7_4_1; unsigned short x_7_4_2; } x_2_3_7; int x_2_3_8; struct Unit<RadianUnitDescription, double> { double x_9_4_1; } x_2_3_9; double x_2_3_10; double x_2_3_11; } x_2_2_2; } x_2_1_2; } x2; } * _cameraContext;
    struct CGSize { 
        double width; 
        double height; 
    }  _canvasSize;
    <MDRenderTarget> * _displayLayer;
    bool  _followsTerrain;
    bool  _isUpdating;
    struct Coordinate2D<Degrees, double> { 
        struct Unit<DegreeUnitDescription, double> { 
            double _value; 
        } latitude; 
        struct Unit<DegreeUnitDescription, double> { 
            double _value; 
        } longitude; 
    }  _lastCoordinate;
    double  _pointsPerMeter;
    struct CGPoint { 
        double x; 
        double y; 
    }  _screenPointInCanvas;
}

@property (nonatomic, readonly) struct { double x1; double x2; } coordinate;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, copy) NSString *description;
@property (nonatomic) <MDRenderTarget> *displayLayer;
@property (nonatomic) bool followsTerrain;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;

- (id).cxx_construct;
- (void).cxx_destruct;
- (struct shared_ptr<md::Anchor> { struct Anchor {} *x1; struct __shared_weak_count {} *x2; })_anchorWithContext:(struct AnchorManager { int (**x1)(); bool x2; struct GlobeView {} *x3; struct MercatorTerrainHeightCache {} *x4; struct unordered_set<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> > { struct __hash_table<md::Anchor *, std::__1::hash<md::Anchor *>, std::__1::equal_to<md::Anchor *>, std::__1::allocator<md::Anchor *> > { struct unique_ptr<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *[], std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > > { struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> **, std::__1::__bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > > { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> {} **x_1_4_1; struct __bucket_list_deallocator<std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > { struct __compressed_pair<unsigned long, std::__1::allocator<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> *> > { unsigned long long x_1_6_1; } x_2_5_1; } x_1_4_2; } x_1_3_1; } x_1_2_1; struct __compressed_pair<std::__1::__hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *>, std::__1::allocator<std::__1::__hash_node<md::Anchor *, void *> > > { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> { struct __hash_node_base<std::__1::__hash_node<md::Anchor *, void *> *> {} *x_1_4_1; } x_2_3_1; } x_1_2_2; } x_5_1_1; } x5; }*)arg1;
- (void)_updateCachedPoint;
- (void)anchorWorldPointDidChange:(void*)arg1;
- (struct { double x1; double x2; })coordinate;
- (void)dealloc;
- (void)destroyAnchor;
- (id)displayLayer;
- (bool)followsTerrain;
- (void)layoutWithContext:(const struct LayoutContext { id x1; struct shared_ptr<md::ViewTransform> { struct ViewTransform {} *x_2_1_1; struct __shared_weak_count {} *x_2_1_2; } x2; id x3; struct shared_ptr<mdc::Camera> { struct Camera {} *x_4_1_1; struct __shared_weak_count {} *x_4_1_2; } x4; unsigned char x5; struct VKEdgeInsets { float x_6_1_1; float x_6_1_2; float x_6_1_3; float x_6_1_4; } x6; struct VKEdgeInsets { float x_7_1_1; float x_7_1_2; float x_7_1_3; float x_7_1_4; } x7; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_8_1_1; struct __shared_weak_count {} *x_8_1_2; } x8; struct shared_ptr<ggl::PolygonBase::MeshMesh> { struct MeshMesh {} *x_9_1_1; struct __shared_weak_count {} *x_9_1_2; } x9; struct shared_ptr<ggl::TextureMesh::MeshMesh> { struct MeshMesh {} *x_10_1_1; struct __shared_weak_count {} *x_10_1_2; } x10; struct StencilManager { unsigned char x_11_1_1; unsigned char x_11_1_2; unsigned char x_11_1_3; struct ClearItem { unsigned char x_4_2_1; struct Matrix<float, 4, 1> { float x_2_3_1[4]; } x_4_2_2; bool x_4_2_3; float x_4_2_4; unsigned char x_4_2_5; unsigned int x_4_2_6; } x_11_1_4; } x11; }*)arg1;
- (struct CGPoint { double x1; double x2; })pointInLayer:(id)arg1 bound:(struct CGRect { struct CGPoint { double x_1_1_1; double x_1_1_2; } x1; struct CGSize { double x_2_1_1; double x_2_1_2; } x2; })arg2;
- (double)pointOffsetForDistanceOffset:(double)arg1;
- (void)setDisplayLayer:(id)arg1;
- (void)setFollowsTerrain:(bool)arg1;
- (void)updateIfNeeded;

@end
